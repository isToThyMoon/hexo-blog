---
title: 04.js内存管理机制
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - root
---

js内存管理为什么会问？

内存管理常常紧跟在闭包之后，因为往往闭包会有内存泄漏的问题。

# JS 内存生命周期
内存管理是每一种编程语言都会具备的一种基本能力。

区别在于，一些语言会将这种能力开放 —— 比如 C 语言中的 malloc() 和 free() 方法 ，这些方法的暴露，使得开发者能够切身感受到内存管理这件事情的存在。

而在另一些语言 —— 比如 JS 中，这种能力是被 “隐藏” 了的：JS 并没有暴露任何内存操作给开发者，而是自己默默地自动完成了所有的管理动作。这是 JS 内存管理不被大多数同学所重视的原因。

JS 的内存生命周期，和大多数程序语言一样，分为三个阶段。

分配内存
内存读写
内存释放

# 栈内存与堆内存

JS 中的数据类型，整体上来说只有两类：基本类型和引用类型。

其中基本类型包括：Sting、Number、Boolean、null、undefined、Symbol。这类型的数据最明显的特征是大小固定、体积轻量、相对简单，它们被放在 JS 的栈内存里存储。

而排除掉基本类型，剩下的数据类型就是引用类型，比如 Object、Array、Function 等等等等。这类数据比较复杂、占用空间较大、且大小不定，它们被放在 JS 的堆内存里存储。

访问基本类型时，过程非常简单：从栈中直接获取该变量的值。

而在访问引用类型时，则需要分两步走：

从栈中获取变量对应对象的引用（即它在堆内存中的地址）
拿着 1 中获取到的地址，再去堆内存空间查询，才能拿到我们想要的数据

# 垃圾回收机制

前面讲完了内存的分配和使用，现在我们来看下内存的释放，也就是 “还坑” 这个动作。

每隔一段时间，JS 的垃圾收集器就会对变量做 “巡检”。当它判断一个变量不再被需要之后，它就会把这个变量所占用的内存空间给释放掉，这个过程叫做垃圾回收。

那么 JS 是如何知道一个变量是否不被需要的呢？ 这里就引出了内存管理的又一个考点 —— 垃圾回收算法。

在 JS 中，我们讨论的垃圾回收算法有两种 —— 引用计数法和标记清除法。

## 引用计数法
这是最初级的垃圾回收算法，它在现代浏览器里几乎已经被淘汰得干干净净，但是仍有一些面试官执着于询问该方法的思路、以便于判断你对 JS 的了解是否足够全面和深入。

在 JS 中，我们强调 “引用” 仅仅用来描述引用类型的内存地址。不过大家要是有一些 JAVA 基础，你会了解到，“引用” 这个概念，其实可以认为它描述的是变量所处那块内存的内存地址 —— 这里所说的 “变量” 是一个泛的概念，它泛指所有类型的变量，而不局限于某一种类型。在 “引用计数法” 中，“引用” 这个概念，其主语也正是 JS 环境中的所有实体。

当我们用一个变量指向了一个值，那么就创建了一个针对这个值的 “引用”。

**在引用计数法的机制下，内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数为 0 时，就判断它 “没用” 了，随即这块内存就会被释放。**

### 引用计数的限制
```
function badCycle() {
  var cycleObj1 = {}
  var cycleObj2 = {}
  cycleObj1.target = cycleObj2
  cycleObj2.target = cycleObj1
}

badCycle()
```

我们知道函数作用域的生命非常短暂，当函数执行完之后，作用域内的变量也会全部被视作 “垃圾” 进而移除。

引用计数法无法甄别循环引用场景下的 “垃圾” 
如果两个变量互相引用，那么他们从引用计数来说将永远无法被清除。这就是内存泄露了。 

## 标记清除法
考虑到引用计数法存在严重的局限性，自 2012 年起，所有浏览器都使用了标记清除算法。可以说，标记清除法是现代浏览器的标准垃圾回收算法。

在标记清除算法中，一个变量是否被需要的判断标准，是它**是否可抵达**。

这个算法有两个阶段，分别是标记阶段和清除阶段：

**标记阶段**：垃圾收集器会先找到根对象，在浏览器里，根对象是 Window；在 Node 里，根对象是 Global。从根对象出发，垃圾收集器会扫描所有可以通过根对象触及的变量，这些对象会被标记为 “可抵达”。
**清除阶段**： 没有被标记为 “可抵达” 的变量，就会被认为是不需要的变量，这波变量会被清除。

自己当然不需要去实现这些方法，但是理解它们还是非常简单的。


# 内存泄漏
该释放的变量（内存垃圾）没有被释放，仍然霸占着原有的内存不松手，导致内存占用不断攀高，带来性能恶化、系统崩溃等一系列问题，这种现象就叫内存泄漏。

如果一个对象没有被引用，它就是垃圾，就会被回收。

内存泄漏：例如ie6中有个bug 如三个对象互相引用，外部没有变量引用它们，ie6 不认为这个垃圾，不会回收，内存一直堆积。
解决：都置为null即可。

## 经典闭包导致的内存泄漏：
先提前感受下闭包保留父级上下文的能力。

```js
function F(){
    let n = 1;
    
    function S(){
        alert(n)
    }
    
    return S //一定要return出去 
}

var Foo = F();
Foo();
```

原因就在于F是S的父函数，而S被赋给了一个全局变量，这导致S因为“可抵达”不会被GC，始终在内存中，而S的存在依赖于F，因此F的上下文开辟的内存也不会被回收，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

```js
var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  var unused = function () {
    if (originalThing) // 'originalThing'的引用
      console.log("嘿嘿嘿");
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () {
      console.log("哈哈哈");
    }
  };
};
setInterval(replaceThing, 1000);
```
unused 和someMethod共享作用域
someMethod在theThing定义的对象内，theThing变量定义在全局变量，一直可以到达，这导致这个someMethod闭包所在作用域不会被释放。
因为共享作用域，unused这个闭包和它引用住的originalThing都在此作用域内，不会被释放。
这导致从第二次起执行的orignalThing不断引用上一次赋值的theThing
第n+1次执行的originalThing都会引用第n次定义的theThing
这导致无法被回收的无用 originalThing 越堆积越多，最终导致严重的内存泄漏


## 误写的全局变量

```js
function test() {
  me = 'xiuyan'
}
```
非严格模式下写代码时，me 而非 var me 这种写法，会导致这个 me 被默默地挂载到全局对象上。

根据我们前面所讲的垃圾回收策略，本来 me 这个变量，如果被 var 声明过，它作为函数作用域内的变量，在函数调用结束后就会消失 —— 这也是我们所期望的。但现在它是一个全局变量了，永远无法被清除。这样的变量一多，问题就来了。

## 忘记清除的 setInterval 和 setTimeout

## 清除不当的 DOM

```js
const myDiv = document.getElementById('myDiv')

function handleMyDiv() {
    // 一些与myDiv相关的逻辑
}

// 使用myDiv
handleMyDiv()

// 尝试”删除“ myDiv
document.body.removeChild(document.getElementById('myDiv'));
```

如果有变量再removechild之前对节点有了引用。
被移除的这个子节点在移除后仍然存在于内存中,只是没有添加到当前文档的DOM树中。如果在之前没有myDiv的引用，那么过一阵子GC会认为该节点无用了，才会回收内存。

那么myDiv这个变量对这个 DOM 的引用仍然存在，它仍然是一块 “可抵达” 的内存。这种你以为已经清除、但其实活得好好的 DOM 一旦堆积，将带来不可预期的内存隐患。